---
title: "07-gea"
format: html
editor: visual
---

### Determining genetic variants associated with environmental gradients with Redundancy analysis (RDA)

### Load required packages

```{r}
knitr::opts_chunk$set(echo = TRUE)
library(vegan)
library(LEA)
library(ggplot2)
library(ggrepel)
library(corrplot)
library(caret)
library(poppr)
library(here)
library(dplyr)
library(tidyr)
library(PCAtest)
library(dartRverse)
```

## Import data:

### Temperature data

#### Only Summer

```{r}
anemone_temps <- read.csv(here::here("project/data", "anemone_temps.csv"))

#summer dataset (for now)
anemone_temps_summer <- anemone_temps %>% filter(season == "Summer")

# oops we don't need Case Inlet
anemone_temps_summer <- anemone_temps_summer %>% filter(site != "CI")

desired_order <- c("GH", "MI", "NR", "CP", "WB", "PG")
anemone_temps_summer$site <- factor(anemone_temps_summer$site, levels = desired_order)

head(anemone_temps_summer)
```

#### Scaling for RDA

```{r}
anemone_temps_numeric <- anemone_temps_summer %>% dplyr::select(where(is.numeric)) # selecting temp metrics

anemone_temps_scaled <- scale(anemone_temps_numeric)  # Mean = 0, SD = 1

head(anemone_temps_scaled)
```

### import .gen file of genotypes

Genotypes from 404 individuals (after clone correction) at 936 SNPs. No missing data. Data format is a genind object generated by the **adegenet** package.

```{r}
# Read first few lines to inspect format
#readLines(here::here("project/output", "genepop_final_cc.gen"), n = 10)

genind_obj <- read.genepop(
  here::here("project/output", "genepop_final_cc.gen"),
  ncode = 2,   # or 3, depending on your allele coding
  quiet = FALSE
)
```

#### Convert to population level allele frequencies (and filter for sites that we have env. data for)

```{r}
pop_factor <- genind_obj$pop  # population assignments
genpop <- genind2genpop(genind_obj, pop = pop_factor)
freq_matrix <- makefreq(genpop, missing = 9, quiet = TRUE)  # 9 for missing data, necessary for LFMM later on

rownames(freq_matrix)  # Shows the population names and their order

# Extract current rownames
old_rownames <- rownames(freq_matrix)

# Get just the first word before the first underscore
new_rownames <- sub("_.*", "", old_rownames)

# Assign new rownames to the matrix
rownames(freq_matrix) <- new_rownames

rownames(freq_matrix)

sites_to_keep <- c("GraysHarbor", "MauryIsland", "Nisqually", "CherryPoint", "WillapaBay", "PortGamble")

freq_matrix_filtered <- freq_matrix[rownames(freq_matrix) %in% sites_to_keep, ]

freq_matrix <- freq_matrix_filtered

# Your desired order of population/site names
desired_order <- c("GraysHarbor", "MauryIsland", "Nisqually", "CherryPoint", "WillapaBay", "PortGamble")

freq_matrix_ordered <- freq_matrix[desired_order, ]

rownames(freq_matrix_ordered) # check
levels(anemone_temps_all$site) #get ready to run the RDA. sanity check. order should match that of frequency matrix

write.table(freq_matrix_ordered, file = "../output/freqmatrix.txt", sep = "\t", row.names = FALSE, col.names = TRUE) # save as text file in output
```
### RDA

```{r}
## check for correlation in temperature metrics
corr_mat <- cor(anemone_temps_scaled)
corrplot::corrplot(corr_mat)

IndexesToDrop <- caret::findCorrelation(cor(anemone_temps_scaled), cutoff = 0.7)

#The variables that remain
corrplot::corrplot(cor(anemone_temps_scaled[,-IndexesToDrop]))

#Save this smaller set
uncorr.temps <- anemone_temps_scaled[,-IndexesToDrop]

#also save a dataset with temp_range include
uncorr.temps.2 <- anemone_temps_scaled[,c(1,2,6)]
```

```{r}
rda.dat<-cbind(as.data.frame(uncorr.temps.2),freq_matrix_ordered)
dim(rda.dat) #we have 6 rows for the populations, 3 columns of temp metrics, and 1,872 columns of alleles

#1. Full RDA
rda.full<-vegan::rda(freq_matrix_ordered ~ 
                          seasonal_mean + 
                          seasonal_max + 
                          seasonal_range, data=as.data.frame(uncorr.temps.2), scale=T)

#adjust for multiple corrections
RsquareAdj(rda.full)

#variance explained by the canonical (RDA) axes
summary(eigenvals(rda.full, model = "constrained"))

#plot constrained eigenvalues
screeplot(rda.full)

#extract % explained by the first 3 axes
axis.perc <- round(100*(summary(rda.full)$cont$importance[2, 1:2]), 2)

# Check the variance inflation factors to make sure that correlations among predictors are not potentially skewing the results (we want these to be below 10)
vif.cca(rda.full)
```

### Significance testing

```{r echo=FALSE}
#anova by terms for each rda
anova.cca(rda.full, permutations = 9999, parallel=20) #global significance p < 0.01
anova.cca(rda.full,permutations = 999, parallel = 12, by="terms") #suggests no temperature metrics are significant
anova.cca(rda.full, permutations=1000, parallel=12, by= "axis") #suggests neither RDA1 nor RDA2 are significant
```
The RDA is significant (Pr(>F) < 0.05). The first axis is significant (Pr(>F) < 0.05), and significant loadings are summer maximum and range.

### Identify outlier loci (adaptive candidates)
```{r}
loadings <- scores(rda.full, choices = 1:2, display = "species")
outliers <- which(loadings^2 > quantile(loadings^2, 0.99))  # Top 1% loading scores

cat("Outlier loci (those with top 1% loading scores):", outliers)
```

### Plot RDA results

```{r}
# Extract site, species, and constraint scores
site_scores <- scores(rda.full, display = "sites", scaling = 3)
species_scores <- scores(rda.full, display = "species", scaling = 3)
biplot_scores <- scores(rda.full, display = "bp", scaling = 3)

# Create a color vector based on site categories
site_colors <-c("#4E9DFE","#FECB00","#994BFF","#250F98","#FD9800","#27BF99")
sites<-anemone_temps_all$site

offset_factor1 <- 1.3 # move labels _ % further from origin
offset_factor2 <- 1.5 # move labels _ % further from origin

ggplot() +
  # Site points
  geom_point(
    data = as.data.frame(site_scores),
    aes(x = RDA1, y = RDA2, color = anemone_temps_all$site),
    size = 3
  ) +
  
  # Species labels (with ggrepel to avoid overlap)
  geom_text_repel(
    data = as.data.frame(species_scores),
    aes(x = RDA1*offset_factor1, y = RDA2*offset_factor1, label = rownames(species_scores)),
    color = "black", size = 3.5
  ) +
  geom_segment(
    data = as.data.frame(species_scores),
    aes(x = 0, y = 0, xend = RDA1, yend = RDA2),
    arrow = arrow(length = unit(0.2, "cm")),
    color = "black", linewidth = 0.6
  ) +
  
  # Constraint arrows (biplot scores)
  geom_segment(
    data = as.data.frame(biplot_scores),
    aes(x = 0, y = 0, xend = RDA1, yend = RDA2),
    arrow = arrow(length = unit(0.2, "cm")),
    color = "gray", linewidth = 0.6
  ) +
  
  # Constraint labels
  geom_text_repel(
    data = as.data.frame(biplot_scores),
    aes(x = RDA1*offset_factor2, y = RDA2*offset_factor2, label = rownames(biplot_scores)),
    color = "gray", size = 4, fontface = "italic",
  ) +
  
  # Styling
  theme_bw() +
  labs(
    x = paste0("RDA1 (", round(summary(rda.full)$cont$importance[2,1] * 100, 1), "%)"),
    y = paste0("RDA2 (", round(summary(rda.full)$cont$importance[2,2] * 100, 1), "%)"),
    color = "ANeMoNe sites"
  ) +
  scale_color_manual(values = site_colors)  # Color palette


```

### Geographic orientation of only sites w/ temp info

![Alt text](C:/Users/lbreit/Documents/lara-zostera/project/images/anemone_sites.png)

### Assessing population structure using PCAdapt

#### Extract allele counts from a genind object

```{r}
# Convert to matrix: individuals in columns, SNPs in rows
geno_mat <- t(tab(genind_obj, NA.method = "asis"))  # Transpose so SNPs are rows

# Replace NAs with 9
geno_mat[is.na(geno_mat)] <- 9

# Write to file (tab-delimited, no row/col names)
write.table(geno_mat, "../data/genotypes.pcadapt", sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)
```

#### Plot results
```{r warning=FALSE}
# Read into pcadapt
pcadapt_data <- read.pcadapt("../data/genotypes.pcadapt", type = "pcadapt")
  
result <- pcadapt(pcadapt_data, K = 10)
# Plot results
plot(result, option = "screeplot") # retain first five PCs
result <- pcadapt(pcadapt_data, K = 5)

populations <- pop(genind_obj) # get populations

#extract variance explained by each PC
singular_vals <- result$singular.values
var_explained <- (singular_vals^2 / sum(singular_vals^2)) * 100

scores <- as.data.frame(result$scores) # scores
populations_short <- sub("[ _].*", "", populations) # Keep only the first word (before a space or underscore)
scores$pop <- populations_short # populations
pc1_var <- round(var_explained[1],2)
pc2_var <- round(var_explained[2],2)


ggplot(scores, aes(V1, V2, color = pop)) +
  geom_point(size = 2) +
  theme_minimal(base_size = 14) +
  labs(
    x = paste0("PC1 (", pc1_var, "%)"),
    y = paste0("PC2 (", pc2_var, "%)")
  ) +
  labs(color = "Sample population") +
  scale_color_manual(values = c(
  "#333333",
  "#27109E", # cherry point
  "#444444",
  "#666666",
  "#888888",
  "#4F9EFF", #grays harbor
  "#AAAAAA",
  "#FDCA00", # maury island
  "#AF72FF", #nisqually reach
  "#CCCCCC",
  "#23AC89", # port gamble
  "#EEEEEE",
  "#FFFFFF",
  "#DDDDDD",
  "#FA9600" #willapa
))
```